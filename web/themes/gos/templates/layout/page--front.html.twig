{% extends "@gos/layout/page.html.twig" %}

{% block page_content %}
  <div>
    <div class="container-square"></div>
    <div class="container">
      <div class="content vh-100 d-flex flex-column justify-content-center">
        <p class="text-display1">Find and discover <br> <span class="text-multicolor">video games from Switzerland</span></p>
        {{ parent() }}
      </div>
    </div>
  </div>

  <script type="text/javascript">
    const container = document.querySelector('.container-square');

    // Settings.
    const squareLifeMin = 50; // squares will die after this time (ms) (random)
    const squareLifeMax = 800;
    const deathAnimTime = 300; // length of the CSS death animation (ms)
    const spawnNumberMin = 1; // number of squares to spawn on each tick (random)
    const spawnNumberMax = 3;
    const spawnDistanceMin = -1; // number of cells based on the active one (under cursor) (random)
    const spawnDistanceMax = 1;
    const squareSize = 60;
    const gridOffset = 30;
    const tick = 50; // speed at which the squares spawn (ms)
    const autoTickMin = 500; // speed at which the squares spawn automatically (ms)
    const autoTickMax = 1000;
    const autoMultiplier = 4; // will spawn X times more and on a surface times wider squares than on mouseover

    // Don't touch those.
    let mousePos = [0,0];
    let activeCell = [0,0];
    let squares = [];
    const activeCellChangeEvent = new Event('activeCellChange');
    let isMouseDown = false;
    let shouldDraw = true;
    let posString;

    // Get the cell coordinate based on a position.
    const getNearestCellCoordinate = position => (Math.round(position / squareSize) - 1) * squareSize + gridOffset;

    // Set the nearest cell as active.
    const setActiveCell = () => {
      const left = getNearestCellCoordinate(mousePos[0]);
      const top = getNearestCellCoordinate(mousePos[1]);

      if (left !== activeCell[0] || top !== activeCell[1]) {
        activeCell = [
          getNearestCellCoordinate(mousePos[0]),
          getNearestCellCoordinate(mousePos[1]),
        ];
        // Dispatch event, might be usefull.
        document.dispatchEvent(activeCellChangeEvent);
      }
    }

    // Handle the mouse moving.
    let timeout = false;
    const onMouseMove = e => {
      // Always check the active cell.
      mousePos = [e.pageX, e.pageY];
      setActiveCell();

      // Spawn squares on each tick.
      if (!timeout) {
        timeout = true;
        setTimeout(() => {
          spawnRandomSquares()
          timeout = false;
        }, tick);
      }
    }

    // The actual spawning.
    const spawnRandomSquares = (pos = activeCell, multiplier = 1) => {
      // Get a random number of random positions around the active cell.
      for (let i = 0; i < randomIntFromInterval(spawnNumberMin * multiplier, spawnNumberMax * multiplier); i++) {
        let newPos = [];

        // Change the square position if we already have one at this place.
        newPos = [
          randomIntFromInterval(spawnDistanceMin, spawnDistanceMax * multiplier) * squareSize + pos[0],
          randomIntFromInterval(spawnDistanceMin, spawnDistanceMax * multiplier) * squareSize + pos[1],
        ];
        const newPosString = `${newPos[0]}|${newPos[1]}`;

        // Add the square if not already present.
        if (!squares.includes(newPosString) && !drawnSquares.includes(newPosString)) {
          squares.push(getStorePosString(newPos));
          setTimeout(() => {
            addRect(newPos, multiplier);
          }, randomIntFromInterval(100, 300));
        }
      }
    }

    // Add a square and kill it after a moment.
    const addRect = (pos = mousePos, multiplier = 1) => {
      const square = document.createElement('div');
      square.classList.add('square');
      positionSquare(square, pos);

      container.appendChild(square);

      // Plan the destruction of the square.
      const deathTime = randomIntFromInterval(squareLifeMin * multiplier, squareLifeMax * multiplier);
      // CSS animation timeout.
      setTimeout(() => {
        square.classList.add('dying');
      }, deathTime - deathAnimTime);
      // Death timeout.
      setTimeout(() => {
        removeRect(square);
      }, deathTime);
    }

    // Destroy the square!
    const removeRect = rect => {
      rect.remove();
      squares = squares.filter(item => item !== rect.dataset.pos);
    }

    // Position the square in the grid, where the mouse is.
    const positionSquare = (square, pos = activeCell) => {
      square.style.top = `${pos[1]}px`;
      square.style.left = `${pos[0]}px`;

      // Store the position for later use.
      square.dataset.pos = `${pos[0]}|${pos[1]}`;
    }

    // Get a random int from an interval.
    const randomIntFromInterval = (min, max) => {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    // Automatically spawn some squares at random times.
    let autoTimer;
    const autoSpawnSquares = () => {
      // Get a random cell in the screen.
      const randomPos = [
        getNearestCellCoordinate(randomIntFromInterval(0, container.offsetWidth)),
        getNearestCellCoordinate(randomIntFromInterval(0, container.offsetHeight)),
      ];

      spawnRandomSquares(randomPos, autoMultiplier);

      // Rerun the same function at random tick.
      autoTimer = setTimeout(autoSpawnSquares, randomIntFromInterval(autoTickMin, autoTickMax));
    }

    // Store the position for later use.
    const getStorePosString = position => `${position[0]}|${position[1]}`;

    // Draw squares on click.
    let drawnSquares = [];
    const drawSquare = () => {
      const square = document.createElement('rect');
      square.classList.add('drawing');
      square.classList.add('square');
      positionSquare(square, activeCell);
      squares.push(posString);
      drawnSquares.push(posString);
      container.appendChild(square);
    }

    // Erase a drawn square.
    const eraseSquare = () => {
      const square = container.querySelector(`[data-pos="${posString}"]`);
      if (square) {
        square.remove();
        drawnSquares = drawnSquares.filter(item => item !== posString)
      }
    }

    // Handle the click.
    const onClick = () => {

    }

    const onMouseDown = () => {
      shouldDraw = !drawnSquares.includes(posString);
      isMouseDown = true;
      drawOrErase();
    }
    const onMouseUp = () => {
      isMouseDown = false;
    }

    // Draw or erase squares.
    const drawOrErase = () => {
      if (shouldDraw) {
        if (!drawnSquares.includes(posString)) {
          drawSquare();
        }
      } else {
        eraseSquare();
      }
    }

    // Handle the change of active cell.
    const onActiveCellChange = () => {
      posString = getStorePosString(activeCell);

      if (isMouseDown) {
        drawOrErase();
      }
    }

    // Initialization!
    const init = () => {
      if (window.Event) {
        document.captureEvents(Event.MOUSEMOVE);
      }

      autoSpawnSquares();

      document.addEventListener('activeCellChange', () => onActiveCellChange(), false);
      container.addEventListener('mousemove', e => window.requestAnimationFrame(() => onMouseMove(e)));
      //container.addEventListener('click', e => onClick(), false);
      container.addEventListener('mousedown', e => onMouseDown());
      container.addEventListener('mouseup', e => onMouseUp());
    }
    window.onload = init;
  </script>
{% endblock %}
